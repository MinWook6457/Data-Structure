
#include<stdio.h>
#include<stdlib.h>
#include <stdbool.h>
#define DEQUEUE_MAX_SIZE 100
typedef char element;

typedef struct  {
	element Dequeue[DEQUEUE_MAX_SIZE];
	int front, rear;
}Dequeuetype;

void init(Dequeuetype* q) {
	q->front = q->rear = 0;
	return;
}

bool is_full(Dequeuetype* q) {
	return ((q->rear + 1) % DEQUEUE_MAX_SIZE == q->front);
}

bool is_empty(Dequeuetype* q) {
	return q->front == q->rear;
}

void push_back(Dequeuetype* q, element item) {
	if (!is_full(q)) {
		q->rear = (q->rear + 1) % DEQUEUE_MAX_SIZE;
		q->Dequeue[q->rear] = item;
	}
	else {
		fprintf(stderr, "메모리가 가득찼습니다.\n");
		exit(1);
	}
	return;
}

void push_front(Dequeuetype* q, element item) {
	if (is_full(q)) {
		fprintf(stderr, "메모리가 가득찼습니다.\n");
		exit(1);
	}
	else {
		q->Dequeue[q->front] = item;
		q->front = (q->front - 1) % DEQUEUE_MAX_SIZE;
	}
}

element pop_front(Dequeuetype* q) {
	if (is_empty(q)) {
		fprintf(stderr, "메모리가 비어있습니다.\n");
		exit(1);
	}
	else {
		q->front = (q->front) + 1 % DEQUEUE_MAX_SIZE;
		return q->Dequeue[q->front];
	}
}
element pop_back(Dequeuetype* q) {
	if (is_empty(q)) {
		fprintf(stderr, "메모리가 비어있습니다.\n");
		exit(1);
	}
	else {
		element temp = q->Dequeue[q->rear];
		q->rear = (q->rear - 1) % DEQUEUE_MAX_SIZE;
		return temp;
	}
}

void check_pelindrome(char I[]) {
	Dequeuetype q;
	init(&q);
	int i = 0, j = 0;
	while (I[i] != NULL) {
		if ('a' <= I[i] && I[i] <= 'z') {
			push_back(&q, I[i]);
			j++;
		}
		else if ('A' <= I[i] && I[i] <= 'Z') {
			push_back(&q, I[i] - ('A' - 'a'));
			j++;
		}
		i++;
	}
	while (!(j == 0 || j == 1)) { // 큐에 있는 모든 요소를 검사한다.
		if (pop_front(&q) != pop_back(&q)) { // 덱의 앞과 뒤를 검사하면서 큐에서 받아온 값이 다르다면 회문이 아님
			printf("Pelindrome이 아닙니다.\n");
			return;
		}
		j -= 2;
	}
	printf("Pelindrome이 맞습니다.\n"); // 끝까지 검사가 완료되면 회문임
	return;
}

int main(void) {
	char I[20] = "mad@.,Am";
	char T[20] = "rac.er";

	check_pelindrome(I);
	check_pelindrome(T);
}